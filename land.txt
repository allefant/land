Land

- the name

It has no special meaning, it's just that in computer games, you make
virtual worlds or lands - and that inspired it as use as name for this.
The only limits of this land should be your imagination, not programming
language obstacles. But if you insist, it could also be a recursive
acronym for "Land All New Design".

- history

Well, I really started working on this version only some days ago. But I
made a library called "land", with the very same goals, about 10-20 years
ago. I actually recovered some files of that, but they require a program
called TASM to work. I actually found a copy of that, and tried to
compile it in dosbox, but still, it wouldn't work. Not that the result
would have been interesting for anyone but me :)

- what it is

Land is, currently, just a simple framework to assist in creating games,
which will work under Windows, Linux and OSX. As well as some others,
basically everything Allegro/SDL/OpenGL can get to run (currently only
Allegro). It doesn't do a lot, just handle a basic game loop for you.
Some may not want this, since it takes control away. But for beginners,
it may make things somewhat simpler.

- features/limitations

* The programming language used is C. This actually is its biggest
  problem, but I haven't found a solution yet. And no, C++ would be no
  solution to the problems I have with C at all.

* No header files. This allows rapid prototyping, in C. Sorta.

* Works with GNU make and gcc only.

* Automated make process, with intelligent dependency handling.

* Load images as single files, from directories, from .zip files, from
  fixed-grid/transparent/color-keyed sheets.

* Free-from multi-layer tilemaps. The layers use no fixed tile-layout,
  you can place there what and where you want. (Of course this includes
  classic tiles.)

* Pixel-perfect collision between tilemap-sprite and sprite-sprite,
  efficient for 1000ds of objects and huge maps. (The algorithm is to
  first check a grid-cash for proximity, then do a bounding-box check,
  then pixel-perfect with pre-generated bit-masks.)

* Parallax scrolling with arbitrary amount of layers. Define some of the
  tilemap layers to be parallax layers - scrolling is handled by Land.

* Exception handling. Instead of checking return values for every
  function, declare what errors you are interested in, and handle them
  all in one function. And use the same mechanism for throwing your own
  exceptions.

- cproto and prototype

One reason why you can't use C/C++ for rapid prototyping is the split into
headers and source code files. This is totatlly un-necessary. E.g. in Java, you
have one .java file for a class. Now, for C, there is a tool called "cproto"
which can at least generate function prototypes automatically from all public
(non-static) functions defined in a .c file. Together with another small tool
which simply copies parts of .c files between #ifdef _PROTOTYPE_ ... #endif /*
_PROTOTYPE_ */ into .h files, this makes manual writing of .h files unnecessary.
Whenever a .c file is modified, the makefile calls those tools to re-create the
.h file. Everything else stays like before. And I can add a new function and
test it in 3 seconds. Same for changing e.g. the number of parameters in a
function. Previously, it meant modifying the headers. And another advantage, I
can define structs and so on inside the .c file when functions working on it are
defined, not in some .h file.

- inheritance and polymorphism

What does the technical inplementation of Land look like, given it is
implemented in C? Well, polymorphism is done by using VTables, similar to e.g.
the Allegro drivers. Inheritance is done by manual aggregation (along with
VTables).

For example, let's say, you want to use a tilemap, but have your own drawing
function called for each tile. Simple create a LandGridInterface object,
replace the ->draw_cell method with your own, and replace the ->vt member of your
LandGrid object with your own LandGridInterface.

TODO: Maybe a macro, something like:

LandGridInterface *my_grid_vtable =
    land_override(land_grid_vtable_normal, cell_draw, my_cell_draw);

- user data

Instead of inheriting your own types, it is much easier to simply attach data to
land types. For example:

int index = land_attach_data(sprite, "mydata", mydata);

or

int index = land_attach_data(sprite, NULL, mydata);

In both cases, you can retrieve the data with:

mydata = land_retrieve_data(sprite, index);

In the first case, also with:

mydata = land_retrieve_named_data(sprite, "mydata")

- containers

  LandList - a doubly linked list of items. Fast insertion and deletion of
  items.

  LandArray - a dynamically growing array. The number of used and allocated
  elements can differ, so can allocate items in advance, or not de-allocate
  items in case more are added shortly.

- maps, layers, tiles, sprites..

  One question still is.. what to do about maximum sprite size? Two brute force
  approaches:
  - render as much overlap cells that the biggest sprite would be catched
    This leaves the solution very high-level.. simply draw a bigger area.
    Drawback is possibly drawing more than necessary most of the time.
  - add a sprite to every cell it covers.. this is somewhat more complicated,
    but can have other advantages as well, like easy collision detection

  Another solution would be to have a maximum size of the cell size in each
  layer - then simply can group large sprites into a layer with a big enough
  cell size. This also would deal with collision detection - a sprite simply can
  never be outside of its cell and the adjacent ones.

- graphics primitives

You can directly use all of Allegro's API, as well as OpenGL. Additionally, with
the time, Land got it's own graphics primitives:

land_color(r, g, b) Sets the color
land_transparency(a) Sets transparency
land_thickness(t) Sets thickness of lines/pixels/rectangles
land_line(x, y, x_, y_) Like the one in Allegro
land_move_to(x, y) Sets the cursor position
land_line_to(x, y) Draws from the current position towards x/y, but not on x/y
itself, and sets the cursor to x/y.
land_line_end(x, y) Like land_line_to, but doesn't change the cursor, and also
draws on x/y.
land_pixel(x, y) Draws a single pixel.

land_clip(x, y, w, h)

How can you draw not to the screen, but into an image?

land_target(image)

So far, the state maintained by a LandDisplay thus is:

 * color_r, color_g, color_b, color_a
 * thickness
 * font
 * text_x, text_y
 * target
 * clip_x, clip_y, clip_w, clip_h

- The land song

lalalala-land
Land is "Land All New Design"
so new so shiny so well designed
lalalala-land
Land in sight!
lalalala-land
lalalalalala-land
lal-land

(that chapter is all the progress I made when trying to work on it drunk)
